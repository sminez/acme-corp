package main

/*
   The idea for this is to combine snooping on acme events/logs with
   a couple of scripts tied to sxhkd bindings that also target acme.

   >> Kick off with sxhkd -c $HOME/.config/sxhkd/sxhkdrc-acme

   Need a way for receiving messages from sxhkd...http?

   This should hopefully allow for some more useful keybindings and UI
   without having to hack on the C source of amce and risk segfaulting
   things again...

   Links
   =====
   man sxhkd
   /home/innes/.config/sxhkd/sxhkdrc-acme
   /home/innes/bin/atext-input

   https://en.wikibooks.org/wiki/Learning_the_vi_Editor/Vim/Modes#Ex-mode

   Planned functionality
   =====================
   - Run body through sed using `atext-input`
   - Auto show current line number in the tag
   - Indent selection/current line
   - Comment selection / current line
*/

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"

	"9fans.net/go/acme"
	"github.com/fsnotify/fsnotify"
)

const (
	triggerPort     = "1992"
	defaultTerminal = "tilix" // Must be on $PATH and support `-e $COMMAND`
)

// A TriggerEvent is generated by POSTing a JSON payload to the snooper root URL
type TriggerEvent struct {
	// TODO: Allow for trigger events to target arbitrary windows?
	Window   int    `json:"window"`
	Op       string `json:"op"`
	Input    string `json:"input"`
	Terminal string `json:"terminal"`
}

// Handler is an extension of the acme.EventHandler interface that also acts
// on log events and trigger events. The functions are passed the text of the
// event in question (with the op for log and trigger) and are expected to determine
// whether they need to act. If they do, they take the appropriate action and return
// true to ack that they have handled the event. If they return false then the event
// is rewritten to the event file for processing by acme.
type Handler interface {
	HandleLog(op, name string) bool
	Trigger(op, input string) bool
	Execute(cmd string) bool
	Look(arg string) bool
}

// An AcmeSnooper snoops on acme events and listens for custom action requests over
// HTTP. This allows for richer reuse of existing acme wrappers from acme.go
type AcmeSnooper struct {
	activeWindow    int // acme window ID
	chTriggerEvents chan TriggerEvent
	chLogEvents     chan acme.LogEvent
}

// NewAcmeSnooper inits an acme snooper and kicks off its HTTP server
func NewAcmeSnooper() *AcmeSnooper {
	a := AcmeSnooper{
		activeWindow:    -1,
		chTriggerEvents: make(chan TriggerEvent),
		chLogEvents:     make(chan acme.LogEvent),
	}

	// Put log events onto a channel so we can select over them and the triggers
	l, _ := acme.Log()
	go func() {
		for {
			e, _ := l.Read()
			a.chLogEvents <- e
		}
	}()

	// Decode the incoming events (if we can) and then push them to the trigger channel
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			fmt.Fprintf(w, "Unable to read data from POST body: %s\n", err)
			return
		}

		var t TriggerEvent
		err = json.Unmarshal(body, &t)
		if err != nil {
			fmt.Fprintf(w, "Unable to unmarshal POST data: %s\n", err)
			return
		}

		a.chTriggerEvents <- t
	})

	// Start listening for trigger events in a goro so that we don't block
	go func() {
		port := fmt.Sprintf(":%s", triggerPort)
		log.Fatal(http.ListenAndServe(port, nil))
	}()

	return &a
}

// push the current window content to the given editor and then read back in the
// modified output. We try to preserve the original file's suffix in order to
// correctly enable syntax highlighting etc in the external editor.
// NOTE: This is always done with the active window (the window that has mouse focus)
func (a *AcmeSnooper) punt(e TriggerEvent) {
	editor := e.Input
	terminal := defaultTerminal

	if e.Terminal != "" {
		terminal = e.Terminal
	}

	if a.activeWindow == -1 {
		log.Print("ERROR: Active window not set")
		return
	}
	w, err := acme.Open(a.activeWindow, nil)
	if err != nil {
		log.Print(err)
	}
	defer w.CloseFiles()

	winInfo, err := acme.Windows()
	if err != nil {
		log.Print(err)
		return
	}

	var tmpName = "acme-punt"

	// Honour the requested window if there was one
	target := a.activeWindow
	if e.Window != 0 {
		target = e.Window
	}

	for _, i := range winInfo {
		if i.ID == target {
			comps := strings.SplitAfter(i.Name, ".")
			if n := len(comps); n > 1 {
				suffix := comps[n-1]
				tmpName = fmt.Sprintf("acme-punt.*.%s", suffix)
			}
			break
		}
	}

	// Get the current window body
	w.Addr(",")
	content, err := w.ReadAll("data")
	if err != nil {
		log.Print(err)
		return
	}

	// Set up a temp file, copy the contents of the current window to it and
	// then open it up in that editor.
	tmpFile, err := ioutil.TempFile("", tmpName)
	if err != nil {
		log.Print(err)
		return
	}

	if _, err := tmpFile.Write(content); err != nil {
		tmpFile.Close()
		log.Fatal(err)
	}
	tmpFile.Close()

	// Kick off a file watcher
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Print(err)
		return
	}

	go func() {
		defer os.Remove(tmpFile.Name()) // clean up
		defer watcher.Close()

		if err := watcher.Add(tmpFile.Name()); err != nil {
			log.Printf("fsnotify-error: %s\n", err)
			return
		}

		for {
			select {
			// watch for events
			case event := <-watcher.Events:
				// log.Printf("fsnotify: %#v\n", event)

				if event.Op&fsnotify.Write == fsnotify.Write {
					// Read the tempfile contents back in and replace the
					// window content with them.
					// TODO: Stash cursor position? Can't guarentee that we'll
					// still have a similar structure when we come back...
					edited, err := ioutil.ReadFile(tmpFile.Name())
					if err != nil {
						log.Print(err)
						return
					}

					w.Clear()
					w.Write("data", edited)
					os.Remove(tmpFile.Name())
					return
				}

				if event.Op&fsnotify.Remove == fsnotify.Remove {
					return
				}

			case err := <-watcher.Errors:
				log.Printf("fsnotify-error: %s\n", err)
			}
		}
	}()

	_, err = exec.Command(terminal, "-e", editor, tmpFile.Name()).CombinedOutput()
	if err != nil {
		log.Print(err)
	}
}

func main() {
	// Listen for OS signals so we can have graceful shutdown
	var progEndSignals = []os.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGHUP,
	}

	chSignals := make(chan os.Signal, 1)
	signal.Notify(chSignals, progEndSignals...)

	a := NewAcmeSnooper()

	// Now we loop over all of the incoming events
	for {
		select {
		case e := <-a.chTriggerEvents:
			switch e.Op {
			case "search":
				log.Printf("Searching for '%s'\n", e.Input)
				// TODO: Should be possible with sending an `Edit` to ctl?

			case "execute":
				log.Printf("Executing '%s'\n", e.Input)
				// TODO: Do we need to inject something into the tag to be able
				//       to select it?

			case "punt":
				log.Printf("Punting to '%s'\n", e.Input)
				// Launch in goro so that we don't block ongoing event handling.
				go a.punt(e)

			default:
				log.Printf("Unknown trigger type: %s\n", e.Op)
			}

		case e := <-a.chLogEvents:
			if e.Op == "" {
				log.Print("acme was closed")
				os.Exit(0)
			}

			if e.Op == "focus" {
				// log.Printf("Setting active window: %d\n", e.ID)
				a.activeWindow = e.ID
			} else {
				log.Printf("%s: %v\n", e.Op, e)
			}

		case <-chSignals:
			// Clear up state and exit
			log.Printf("Shutting down...\n")
			os.Exit(0)
		}
	}
}
