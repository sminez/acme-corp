package main

/*
   The idea for this is to combine snooping on acme events/logs with
   a couple of scripts tied to sxhkd bindings that also target acme.
*/

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"9fans.net/go/acme"
	"github.com/sminez/acme-corp/afmt"
)

const (
	triggerPort = "1992"
)

// A TriggerEvent is generated by POSTing a JSON payload to the snooper root URL
type TriggerEvent struct {
	// TODO: Allow for trigger events to target arbitrary windows?
	// Window   int    `json:"window"`
	Op       string `json:"op"`
	Input    string `json:"input"`
	Terminal string `json:"terminal"`
}

// An AcmeSnooper snoops on acme events and listens for custom action requests over
// HTTP. This allows for richer reuse of existing acme wrappers from acme.go
type AcmeSnooper struct {
	activeWindow    int // acme window ID
	chTriggerEvents chan TriggerEvent
	chLogEvents     chan acme.LogEvent
}

// NewAcmeSnooper inits an acme snooper and kicks off its HTTP server
func NewAcmeSnooper() *AcmeSnooper {
	a := AcmeSnooper{
		activeWindow:    -1,
		chTriggerEvents: make(chan TriggerEvent),
		chLogEvents:     make(chan acme.LogEvent),
	}

	return &a
}

func (a *AcmeSnooper) snoop(chSignals chan os.Signal) {
	go a.tailLog()
	go a.serveHTTP()

	for {
		select {
		case e := <-a.chTriggerEvents:
			switch e.Op {
			case "execute":
				log.Printf("Executing '%s'\n", e.Input)
				// TODO: Do we need to inject something into the tag to be able
				//       to select it?

			default:
				log.Printf("Unknown trigger type: %s\n", e.Op)
			}

		case e := <-a.chLogEvents:
			switch e.Op {
			case "":
				os.Exit(0) // acme was closed

			case "focus":
				a.activeWindow = e.ID

			case "put":
				if e.Name == "" {
					continue
				}
				for _, ft := range afmt.FTYPES {
					if ft.matches(&e) {
						ft.reformat(&e)
					}
				}

			default:
				// log.Printf("%s: %v\n", e.Op, e)
			}

		case <-chSignals:
			os.Exit(0)
		}
	}
}

func (a *AcmeSnooper) serveHTTP() {
	http.HandleFunc("/", a.triggerHandler)
	http.HandleFunc("/active", a.activeHandler)

	port := fmt.Sprintf(":%s", triggerPort)
	log.Fatal(http.ListenAndServe(port, nil))
}

// Put log events onto a channel so we can select over them and the triggers
func (a *AcmeSnooper) tailLog() {
	l, _ := acme.Log()
	for {
		e, _ := l.Read()
		a.chLogEvents <- e
	}
}

func (a *AcmeSnooper) triggerHandler(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Unable to read data from POST body: %s\n", err)
		return
	}

	var t TriggerEvent
	err = json.Unmarshal(body, &t)
	if err != nil {
		fmt.Fprintf(w, "Unable to unmarshal POST data: %s\n", err)
		return
	}

	a.chTriggerEvents <- t
}

func (a *AcmeSnooper) activeHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "%d\n", a.activeWindow)
}

func main() {
	var progEndSignals = []os.Signal{
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGHUP,
	}

	chSignals := make(chan os.Signal, 1)
	signal.Notify(chSignals, progEndSignals...)

	a := NewAcmeSnooper()
	a.snoop(chSignals)
}
